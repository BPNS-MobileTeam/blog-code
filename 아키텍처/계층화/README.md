# 애플리케이션 계층화 


* 프레젠테이션 (UI) 계층
* 도메인 로직 (비지니스 로직) 계층
  * 서비스/시스템의 핵심 로직
  * 일반적으로 다음과 같은 역할을 한다.
    * 데이터를 저장
    * 저장된 데이터를 이용한 연산 
    * 프레젠테이션 계층에서 받은 데이터의 유효성 검사
    * 작업 대상이 될 데이터 (Data) 로직 수행
* 데이터 접근 (Data access) 계층
  * Database
  * Message Queue
  * 외부 API와의 통신

일반적인 웹 애플리케이션이라고 한다면, 

* HTTP 요청 처리 및 HTML 렌더링에 대해 알고 있는 웹 계층 
* 유효성 검사 및 계산을 포함하는 비즈니스 논리 계층 
* 데이터베이스 또는 원격 서비스에서 영구 데이터를 관리하는 방법을 분류하는 데이터 액세스 계층

프레젠테이션 계층 - 도메인 로직 계층 - 데이터 접근 계층

Presentation-Domain-Data Pattern

## 계층화 해야하는 이유

전반적으로 나는 이것이 많은 응용 프로그램에 대한 효과적인 모듈화 형식이며 내가 정기적으로 사용하고 권장하는 형식이라는 것을 알았습니다. 
(나에게) 가장 큰 장점은 주의 범위 를 줄일 수 있다는 것 입니다.  
세 가지 주제에 대해 상대적으로 독립적으로 생각할 수 있게 함으로써. 

* 도메인 논리 코드로 작업할 때 대부분 UI를 무시하고 데이터 소스와의 상호 작용을 필요한 데이터를 제공하고 원하는 대로 업데이트하는 추상 함수 집합으로 처리할 수 있습니다. 
* 데이터 액세스 계층에서 작업할 때 내 인터페이스에 필요한 형식으로 데이터를 랭글링하는 세부 사항에 중점을 둡니다. 
* 프레젠테이션 작업을 할 때 UI 동작에 집중할 수 있습니다. 표시하거나 업데이트할 데이터를 함수 호출에 의해 마술처럼 나타나는 것처럼 처리합니다. 이러한 요소를 분리함으로써 각 부분에서 생각의 범위를 좁혀서 내가 해야 할 일을 더 쉽게 따라갈 수 있습니다.

이러한 범위의 축소는 프로그래밍에 대한 시퀀스를 의미하지 않습니다.  
일반적으로 레이어 사이를 반복해야 한다는 것을 알았습니다. UX에 대한 초기 이해를 바탕으로 데이터 및 도메인 레이어를 구축할 수도 있지만 UX를 개선할 때 데이터 레이어를 변경해야 하는 도메인을 변경해야 합니다. 그러나 이러한 종류의 교차 레이어 반복을 사용하더라도 변경을 수행할 때 한 번에 한 레이어에 집중하는 것이 더 쉽다는 것을 알았습니다.  

리팩토링의 두 가지 모자를 사용 하여 사고 모드를 전환하는 것과 유사합니다.

> 리팩토링의 2가지 모자는 리팩토링1, 리팩토링2 모두에서 언급하고 있는 용어

### 모듈 대체성

모듈화해야 하는 또 다른 이유는 다른 모듈 구현 을 대체 할 수 있도록 하기 위해서 입니다. 이러한 분리를 통해 동일한 도메인 논리를 복제하지 않고도 여러 프레젠테이션을 작성할 수 있습니다. 여러 프레젠테이션은 웹 앱과 모바일 네이티브 앱, 스크립팅용 API 또는 구식 명령줄 인터페이스가 있는 웹 앱의 개별 페이지일 수 있습니다. 데이터 소스를 모듈화하면 데이터베이스 기술의 변화에 ​​유연하게 대처할 수 있고 거의 통지 없이 변경될 수 있는 지속성을 위한 서비스를 지원할 수 있습니다. 그러나 데이터 액세스 대체가 데이터 소스 계층을 분리하는 동인이라는 말은 자주 듣는 반면 실제로 수행하는 사람은 거의 들어 본 적이 없습니다.

### 좀 더 용이한 테스트

Modularity는 또한 테스트 가능성을 지원합니다. 이는 SelfTestingCode 의 열렬한 팬으로서 자연스럽게 저에게 어필합니다 . 모듈 경계 는 테스트를 위한 좋은 어포던스인 이음새를 노출 합니다. UI 코드는 테스트하기 까다로운 경우가 많으므로 UI를 통해 프로그램에 액세스하기 위해 체조를 할 필요 없이 쉽게 테스트할 수 있는 도메인 계층에 가능한 한 많은 논리를 가져오는 것이 좋습니다.  
데이터 액세스는 느리고 어색한 경우가 많으므로 데이터 계층에서 TestDoubles 를 사용 하면 도메인 논리 테스트가 훨씬 쉽고 응답성이 좋습니다.

대체 가능성과 테스트 가능성은 확실히 이 계층화의 이점이지만, 이러한 이유 중 하나가 없더라도 여전히 이와 같은 계층으로 나눌 것임을 강조해야 합니다.  

관심 범위 축소 이유는 그 자체로 충분합니다.

### 도메인 로직을 구분하는 방법

이 로직이 **도메인 로직인지 아닌지** 구분하는 것은 꽤나 어렵다.  
그래서 이럴때는 마틴파울러의 PEAA (엔터프라이즈 애플리케이션 아키텍처 패턴)에 나온 방법을 주로 사용하면 좋다.  

* 웹 애플리케이션이라면, CLI로 이 애플리케이션을 실행해야 한다고 가정해본다.
* RDBMS로 저장되는 애플리케이션이 있다면 저장 방식에 XML 파일도 추가되어야 함을 가정해본다.

> 근본적으로 계층이 추가/변경되는 경우이다.

만약 위와 같이 계층이 추가/변경되기 위해서 **코드를 복사해야한다면** 그 로직이 바로 도메인 로직이다.  

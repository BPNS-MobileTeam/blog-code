# 애플리케이션 계층화

> 마틴 파울러의 책, PoEAA ([Pattern of Enterprise Application Architecture: 엔터프라이즈 애플리케이션 아키텍처 패턴](http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9791158390174&orderClick=LEa&Kc=) 을 기반으로 합니다.)

학교 다닐때 잠깐 JAVA 관련 수업을 들은적이 있다.  
그때 수업 내용은 [넷빈즈(Netbeans) IDE](https://namu.wiki/w/%EB%84%B7%EB%B9%88%EC%A6%88)를 통해 JAVA로 윈도우 애플리케이션을 만드는 것이였다.  

간단한 시간표 관리 프로그램을 만드는 과제는 얼핏보면 웹과 크게 달라보이지 않았다.  

![timetable](./images/timetable.png)

(이미지 출처: [blog.asata.pe.kr](https://blog.asata.pe.kr/486))  

당시의 개발은 간단했다.  
JAVA (Swing)로 애플리케이션 UI와 로직을 작성하고, Database에 접근해서 시간표를 저장하고 불러오는 방식이였다.  

만약 이 프로그램을 **웹으로 전환**해야한다면 어땠을까?  
JAVA Swing 코드를 걷어내고,



![1](./images/1.png)

* 프레젠테이션 (UI) 계층
   * HTTP 요청 처리
   * HTML 렌더링과 같은 뷰 처리
* 도메인 로직 (비지니스 로직) 계층
  * 서비스/시스템의 핵심 로직
  * 일반적으로 다음과 같은 역할을 한다.
    * 데이터를 저장
    * 저장된 데이터를 이용한 연산
    * 프레젠테이션 계층에서 받은 데이터의 유효성 검사
    * 작업 대상이 될 데이터 (Data) 로직 수행
* 데이터 접근 (Data access) 계층
  * Database
  * Message Queue
  * 외부 API와의 통신 등

일반적인 웹 애플리케이션이라고 한다면,

* HTTP 요청 처리 및 HTML 렌더링에 대해 알고 있는 웹 계층
* 유효성 검사 및 계산을 포함하는 비즈니스 논리 계층
* 데이터베이스 또는 원격 서비스에서 영구 데이터를 관리하는 방법을 분류하는 데이터 액세스 계층

프레젠테이션 계층 - 도메인 로직 계층 - 데이터 접근 계층

Presentation-Domain-Data Pattern


## 계층화 해야하는 이유

계층화는 (좀 더 범위가 넓은) 효과적인 모듈화 방식이다.  
계층화를 비롯해서 **모듈화를 해야하는 이유**로는 크게 3가지 이유가 있다.

### 관심 범위 축소

프레젠테이션 계층 / 도메인 계층 / 데이터 계층 이라는 3 계층에 대해 독립적으로 생각할 수 있게 된다.

* 도메인 논리 코드로 작업할 때 대부분 UI를 무시하고 데이터 소스와의 상호 작용을 필요한 데이터를 제공하고 원하는 대로 업데이트하는 추상 함수 집합으로 처리할 수 있다.
* 데이터 액세스 계층에서 작업할 때 내 인터페이스에 필요한 형식으로 데이터를 랭글링하는 세부 사항에 중점을 둔다.
* 프레젠테이션 작업을 할 때 UI 동작에 집중할 수 있다. 표시하거나 업데이트할 데이터를 함수 호출에 의해 마술처럼 나타나는 것처럼 처리한다. 이러한 요소를 분리함으로써 각 부분에서 생각의 범위를 좁혀서 내가 해야 할 일을 더 쉽게 따라갈 수 있다.

이러한 범위의 축소는 개발에 대한 순서를 의미하지 않다.  
일반적으로 레이어 사이를 반복해야 한다는 것을 알았다.  
UX에 대한 초기 이해를 바탕으로 데이터 및 도메인 레이어를 구축할 수도 있지만 UX를 개선할 때 데이터 레이어를 변경해야 하는 도메인을 변경해야 한다.  
그러나 이러한 종류의 교차 레이어 반복을 사용하더라도 변경을 수행할 때 한 번에 한 레이어에 집중하는 것이 더 쉽다는 것을 알았다.  

리팩토링의 두 가지 모자를 사용 하여 사고 모드를 전환하는 것과 유사한다.

> 리팩토링의 2가지 모자는 리팩토링1,2 (2.2 두개의 모자) 모두에서 언급하고 있는 용어로 소프트웨어 개발의 목적이 **기능 추가**냐 **리팩토링**이냐를 명확히 구분하는 것을 **비유**한 것이다.  
> 기능을 추가할 때는 **기능 추가 모자**를 쓰고 기존 코드는 절대 건드리지 않은채 새 기능을 추가하고, 리팩토링할 때는 **리팩토링 모자**를 쓴 다음 기능추가는 절대 하지 않고 오로지 코드 재구성만 한다.  
> 항상 현재 **본인이 쓰고 있는 모자가 무엇인지** 인지하고, 그에 따른 미묘한 **작업 방식의 차이를 분명하게 인식**하는 일종의 장치처럼 사용된다.

### 모듈 대체성

또 다른 이유는 다른 모듈 구현체로 쉽게 대체하기 위함이다.  
이러한 분리를 통해 동일한 도메인 논리를 복제하지 않고도 여러 프레젠테이션을 작성할 수 있다.  
여러 프레젠테이션은 웹 앱과 모바일 네이티브 앱, 스크립팅용 API 또는 CLI 인터페이스가 있는 웹 앱의 개별 페이지일 수 있다.  
데이터 소스를 모듈화하면 데이터베이스 기술의 변화에 ​​유연하게 대처할 수 있고 거의 통지 없이 변경될 수 있는 지속성을 위한 서비스를 지원할 수 있다.  
그러나 데이터 액세스 대체가 데이터 소스 계층을 분리하는 동인이라는 말은 자주 듣는 반면 실제로 수행하는 사람은 거의 들어 본 적이 없다.

### 좀 더 용이한 테스트

마지막 3번째 장점은 테스트를 좀 더 용이하게 가능하게 해준다는 점이다.  
이는 SelfTestingCode 의 열렬한 팬으로서 자연스럽게 저에게 어필한다.  
모듈 경계 는 테스트를 위한 좋은 어포던스인 이음새를 노출 한다.  
UI 코드는 테스트하기 까다로운 경우가 많으므로 UI를 통해 프로그램에 액세스하기 위해 체조를 할 필요 없이 쉽게 테스트할 수 있는 도메인 계층에 가능한 한 많은 논리를 가져오는 것이 좋다.  
데이터 액세스는 느리고 어색한 경우가 많으므로 데이터 계층에서 TestDoubles 를 사용 하면 도메인 논리 테스트가 훨씬 쉽고 응답성이 좋다.

변경 용이성과 용이한 테스트는 확실히 계층화의 장점이다.  
하지만 이 2가지 이유중 하나가 없더라도 **관심 범위 축소**라는 이유만으로도 계층화는 적용해야만 한다.

### 도메인 로직을 구분하는 방법

이 로직이 **도메인 로직인지 아닌지** 구분하는 것은 꽤나 어렵다.  
그래서 이럴때는 마틴파울러의 PEAA (엔터프라이즈 애플리케이션 아키텍처 패턴)에 나온 방법을 주로 사용하면 좋다.  

* 웹 애플리케이션이라면, CLI로 이 애플리케이션을 실행해야 한다고 가정해본다.
* RDBMS로 저장해야하는 애플리케이션이 있다면 저장 방식에 XML 파일도 추가되는 것을 가정해본다.

> 근본적으로 계층이 추가/변경되는 경우이다.

만약 위와 같이 계층이 추가/변경되기 위해서 **코드를 복사해야한다면** 그 로직이 바로 도메인 로직이다.  
